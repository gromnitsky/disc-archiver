#!/usr/bin/env node

'use strict';

let readline = require('readline')
let path = require('path')
let util = require('util')

let u = require('./lib/u')

// we cannot just indexOf for `..${path.sep}` because under Cygwin
// `../foo` would be a valid path
let is_path_relative = function(str) {
    return str.match(/\.\.[\\/]/)
}

class FileRule {

    // cache -- a shared hash
    constructor(line, target_dir, cache) {
	line = line.trim().split("\t")
	if (is_path_relative(line[1])) throw new Error("relative paths aren't allowed")

	this.cache = cache
	this.target_dir = target_dir

	this.dir = line[0]
	this.prerequisite = line[1]
	this.cache[this.prerequisite] = this.cache[this.prerequisite] || {
	    part: 0,
	    total: 0
	}
	this.cache[this.prerequisite].total++
	this._target = null

	this.pos_from = parseInt(line[2])
	this.pos_to = parseInt(line[3])
    }

    partial() {
	return !(isNaN(this.pos_from) && isNaN(this.pos_to))
    }

    target() {
	if (this._target) return this._target

	let name = this.prerequisite
	if (this.partial()) {
	    let f = this.cache[this.prerequisite]
	    f.part += 1
	    let cur = u.pad(f.part, u.numlen(f.total))
	    name = `${this.prerequisite}.part-${cur}-of-${f.total}`
	}
	this._target = path.join(this.target_dir, this.dir, name)
	return this._target
    }

    // 1/file.dump: file.dump
    //         @mkdir ...
    //         cp $< $@
    toString() {
	let r = []
	r.push(`${this.target()}: ${this.prerequisite}`)
	r.push('\t@mkdir -p $(dir $@)')
	if (this.partial()) {
	    r.push(`\tdd if=$< of=$@ bs=64K iflag=skip_bytes,count_bytes skip=${this.pos_from} count=${this.pos_to - this.pos_from + 1}`)
	} else {
	    r.push('\tcp $< $@')
	}
	return r.join("\n")
    }

}

let generate_makefile = function(filerules) {
    if (!filerules || filerules.length === 0) return ""
    let output_iso_dir = path.join(path.dirname(filerules[0].target_dir), 'iso')

    let r = [`# Auto-generated by ${path.basename(process.argv[1])}, don't edit.`]
    r.push("# Run `make` to create .iso files.\n")
    r.push("mkisofs := xorrisofs\n")
    r.push(".PHONY: compile")
    r.push("compile:\n")
    let compile = []

    let tree = {}
    for (let rule of filerules) {
	r.push(rule.toString())

	// put every file under its dir
	tree[rule.dir] = tree[rule.dir] || []
	tree[rule.dir].push(rule)
    }

    r.push("")

    // 1.iso: file1.dump file2.dump
    //         @mkdir ...
    //         xorrisofs ...
    for (let dir in tree) {
	let files = tree[dir]
	let target = `${path.join(output_iso_dir, dir)}.iso`
	let deps = files.map( (idx) => idx.target()).join(" \\\n\t\t")

	r.push(`${target}: ${deps}`)
	r.push('\t@mkdir -p $(dir $@)')
	r.push('\t$(mkisofs) -rJ -input-charset utf-8 -iso-level 3 $(mkisofs.opt) -o $@ $(dir $<)')
	compile.push(target)
    }

    r.push("")
    r.push (`compile: ${compile.join(" \\\n\t")}`)
    r.push("")

    return r.join("\n")
}


let rl = readline.createInterface({ input: process.stdin })
let out_dir = process.argv[2] || "out"

let cache = {}
let filerules = []
rl.on('line', (line) => {
    if (!line.match(/^\s*$/))
	filerules.push(new FileRule(line, path.join(out_dir, "src"), cache))
})

rl.on('close', () => {
    process.stdout.write(generate_makefile(filerules))
})
