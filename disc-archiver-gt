#!/usr/bin/env node

'use strict';

let readline = require('readline')
let path = require('path')
let util = require('util')

let parse_line = function(line) {
    line = line.trim().split("\t")
    return {
	dir: line[0],
	name: line[1],
	pos_from: parseInt(line[2]),
	pos_to: parseInt(line[3]),

	partial() { return !(isNaN(this.pos_from) && isNaN(this.pos_to)) }
    }
}

class FileBank {
    constructor(data) {
	this.files = {}
	for (let file of data) {
	    if (this.files[file.name]) {
		this.files[file.name].max += 1
	    } else {
		this.files[file.name] = {
		    max: 1,
		    current: 0
		}
	    }
	}
    }

    local_name(str) {
	let common_prefix = path.dirname(process.cwd()) + path.sep
	let abs = path.resolve(str)
	return abs.replace(common_prefix, '')
    }

    // file is an object that parse_line() returns
    name(file) {
	if (!file.partial()) return file.name

	let f = this.files[file.name]
	f.current += 1
	// FIXME: pad f.current
	return `${this.local_name(file.name)}.part-${f.current}-of-${f.max}`
    }
}

let generate_makefile = function(data, output_dir) {
    let output_iso_dir = path.join(output_dir, 'iso')
    let output_src_dir = path.join(output_dir, 'src')

    let r = [`# Auto-generated by ${path.basename(process.argv[1])}, don't edit.`]
    r.push("# Run `make` to create .iso files.\n")
    r.push(".PHONY: compile")
    r.push("compile:\n")
    let compile = []

    // put every file under its dir
    let tree = {}
    for (let file of data) {
	tree[file.dir] = tree[file.dir] || []
	tree[file.dir].push(file)
    }

    // 1.iso: file1.dump file2.dump
    let bank = new FileBank(data)
    for (let dir in tree) {
	let files = tree[dir]
	let target = `${path.join(output_iso_dir, dir)}.iso`
	let deps = files.map( (idx) => {
	    return path.join(output_src_dir, idx.dir, bank.name(idx))
	}).join(" \\\n\t")

	r.push(`${target}: ${deps}`)
	r.push('\t@mkdir -p $(dir $@)')
	// FIXME: genisoimage
	r.push('\ttouch $@')
	compile.push(target)
    }

    r.push("")
    r.push (`compile: ${compile.join(" \\\n\t")}`)
    r.push("")

    // 1/file1.dump: file.dump
    //         mkdir ...
    //         cp $< $@
    bank = new FileBank(data)
    for (let file of data) {
	let target = path.join(output_src_dir, file.dir, bank.name(file))
	r.push(`${target}: ${file.name}`)
	r.push('\t@mkdir -p $(dir $@)')
	if (file.partial()) {
	    r.push(`\tdd if=$< of=$@ iflag=skip_bytes,count_bytes skip=${file.pos_from} count=${file.pos_to - file.pos_from + 1}`)
	} else {
	    r.push('\tcp $< $@')
	}
    }

    return r.join("\n")
}

let rl = readline.createInterface({ input: process.stdin })

let data = []
rl.on('line', (line) => {
    let file = parse_line(line)
    data.push(file)
})

rl.on('close', () => {
    let out_dir = process.argv[2] || "out"
    process.stdout.write(generate_makefile(data, out_dir) + "\n")
})
